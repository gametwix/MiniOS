[GLOBAL read_eip]
read_eip:
  pop eax
  jmp eax 

[GLOBAL copy_page_physical]
copy_page_physical:
   push ebx              ; Согласно to __cdecl мы должны сохранить содержимое EBX.
   pushf                 ; помещаем в стек EFLAGS с тем, чтобы могли оттуда забрать и заново включить прерывания
                         ; Далее, если прерывания по какой-либо причине были включены.
   cli                   ; Отключаем прерывания, теперь наши действия прерываться не будут.
                         ; ПЕРЕД тем, как страничная организация памяти будет отключена, загружаем!
   mov ebx, [esp+12]     ; адрес, откуда делается копирование
   mov ecx, [esp+16]     ; адрес, куда выполняется копирование

   mov edx, cr0          ; Берем регистр управления ...
   and edx, 0x7fffffff   ; и ...
   mov cr0, edx          ; отключаем страничную организацию памяти.

   mov edx, 1024         ; 1024*4 байтов = копируется 4096 байтов

.loop:
   mov eax, [ebx]        ; Берем слово из адреса, откуда делается копирование
   mov [ecx], eax        ; Запоминаем его по адреса, куда выполняется копирование
   add ebx, 4            ; Адрес источника копирования += sizeof(word)
   add ecx, 4            ; Адрес, куда делается копирование += sizeof(word)
   dec edx               ; Осталось скопировать на одно слово меньше
   jnz .loop

   mov edx, cr0          ; Снова берем регистр управления
   or  edx, 0x80000000   ; и ...
   mov cr0, edx          ; включаем страничное управление памятью.

   popf                  ; Выталкиваем из стека EFLAGS.
   pop ebx               ; Помещаем исходное значение обратно в EBX.
   ret 